#include <iostream>
#include <sstream>
#include <string>
#include <TCanvas.h>
#include <TFile.h>
#include <TH1.h>
#include <THStack.h>
#include <TLegend.h>
#include <TStyle.h>
#include <vector>
#include <TF1.h>
#include <TPaveLabel.h>
#include <TPaveText.h>
#include <TText.h>
#include <TLine.h>
#include <cmath>
#include <memory>
#include <iomanip>

using namespace std;


//for debugging only  functions ------------------------

void DebugTwoHistRatio(const TH1* hist1, const TH1* hist2)
{
	assert ((hist1 != NULL &&  hist2 != NULL) && "DebugStatErr got a NULL hist");

	TH1* h1 = (TH1*) hist1->Clone("h1copy");
	TH1* h2 = (TH1*) hist2->Clone("h2copy");
	h1->Scale(1./(1.0 * h1->Integral()));
	h2->Scale(1./(1.0 * h2->Integral()));
	
	std::cout << "bin\trat" << std::endl;
	
	for (int bin=1; bin <= h1->GetNbinsX(); ++bin)
	{
		if (h1->GetBinContent(bin))
		{
			double cval = h1->GetBinContent(bin);
			double uval = h2->GetBinContent(bin);
			//c->SetBinContent(bin, uval/cval - 1);
			//cdhistrat->SetBinContent(bin, dval/cval - 1);
			float rat = uval/cval - 1;
			std::cout << bin << "\t" << rat << std::endl;
		}

	}
	
	
	h2->Add(h1,-1);
	h2->Divide(h1);
	h2->SetTitle("#gamma sideband and #gamma MC compared (each normlaized to unity before comparison)");
	new TCanvas();
	gPad->SetGridx();
	gPad->SetGridy();
	h2->SetMarkerStyle(20);
	h2->SetMarkerColor(kBlue);
	h2->Draw("P");
	
  TLegend *leg = new TLegend (0.7,0.6,0.9,0.9);
  leg->SetTextFont(42);
  leg->SetTextSize(0.03);
  
  leg->AddEntry(h2,"#frac{#gamma MC}{Sideband} - 1");
  leg->Draw();
 
}


//plots the Stat err for each hist
void DebugStatErr(const TH1* zeejet, const TH1* zmmjet,
						const TH1* zttjet, const TH1* wenjet, 
						const TH1* wmnjet, const TH1* wtnjet, 
						const TH1* mcphojet,  const TH1* qcdjet, const TH1* sumbg = 0)
{


	assert ((zeejet != NULL && zmmjet != NULL && zttjet != NULL 
				&& wenjet != NULL && wmnjet != NULL && wtnjet != NULL 
				&& mcphojet != NULL)
				&& "DebugStatErr got a NULL hist");


	TH1* zee = (TH1*) zeejet->Clone("zeejet_copy");
	TH1* zmm = (TH1*) zmmjet->Clone("zmmjet_copy");
	TH1* ztt = (TH1*) zttjet->Clone("zttjet_copy");
	TH1* wen = (TH1*) wenjet->Clone("wenjet_copy");
	TH1* wmn = (TH1*) wmnjet->Clone("wmnjet_copy");
	TH1* wtn = (TH1*) wtnjet->Clone("wtnjet_copy");
	TH1* phomc = (TH1*) mcphojet->Clone("phomcjet_copy");
	TH1* qcd = (TH1*) qcdjet->Clone("qcd_copy");

	TH1* sumBG=0;
	if (sumbg)
	{
		sumBG = (TH1*) sumbg->Clone("hist_err_copy");
	}

	//assuming all hists are rebinned (same sizes)
	for (int i=1; i <=zee->GetNbinsX();++i)
	{
		if (zee->GetBinContent(i))
		{
			zee->SetBinContent(i, zee->GetBinError(i)/zee->GetBinContent(i));
			zee->SetBinError(i,0);
		}
		if (zmm->GetBinContent(i))
		{
			zmm->SetBinContent(i, zmm->GetBinError(i)/zmm->GetBinContent(i));
			zmm->SetBinError(i,0);
		}
		if (ztt->GetBinContent(i))
		{
			ztt->SetBinContent(i, ztt->GetBinError(i)/ztt->GetBinContent(i));
			ztt->SetBinError(i,0);
		}
		if (wen->GetBinContent(i))
		{
			wen->SetBinContent(i, wen->GetBinError(i)/wen->GetBinContent(i));
			wen->SetBinError(i,0);
		}
		if (wmn->GetBinContent(i))
		{
			wmn->SetBinContent(i, wmn->GetBinError(i)/wmn->GetBinContent(i));
			wmn->SetBinError(i,0);
		}
		if (wtn->GetBinContent(i))
		{
			wtn->SetBinContent(i, wtn->GetBinError(i)/wtn->GetBinContent(i));
			wtn->SetBinError(i,0);
		}
		if (phomc->GetBinContent(i))
		{
			phomc->SetBinContent(i, phomc->GetBinError(i)/phomc->GetBinContent(i));
			phomc->SetBinError(i,0);
		}
		if (qcd->GetBinContent(i))
		{
			qcd->SetBinContent(i, qcd->GetBinError(i)/qcd->GetBinContent(i));
			qcd->SetBinError(i,0);
		}
		if (sumBG)
		{
			if (sumBG->GetBinContent(i))
			{
				sumBG->SetBinContent(i, sumBG->GetBinError(i)/sumBG->GetBinContent(i));
				sumBG->SetBinError(i,0);
			}
		}
	}

	zee->SetMarkerStyle(20);
	zmm->SetMarkerStyle(22);
	ztt->SetMarkerStyle(23);
	wen->SetMarkerStyle(20);
	wmn->SetMarkerStyle(22);
	wtn->SetMarkerStyle(23);
	phomc->SetMarkerStyle(21);
	qcd->SetMarkerStyle(21);
	if (sumBG)
	{
		sumBG->SetMarkerStyle(21);
		sumBG->SetMarkerColor(kCyan);
	}

	zee->SetMarkerColor(kRed);
	zmm->SetMarkerColor(kRed);
	ztt->SetMarkerColor(kRed);
	wen->SetMarkerColor(kBlue);
	wmn->SetMarkerColor(kBlue);
	wtn->SetMarkerColor(kBlue);
	phomc->SetMarkerColor(kGreen);
	qcd->SetMarkerColor(kYellow);
	
	zee->SetTitle("Relative Statistical Error in MC samples before scaling");

  TLegend *leg = new TLegend (0.7,0.6,0.9,0.9);
  leg->SetTextFont(42);
  leg->SetTextSize(0.03);
  
  leg->AddEntry(zee,"Zee");
  leg->AddEntry(zmm,"Zmm");
  leg->AddEntry(ztt,"Ztt");
  leg->AddEntry(wen,"Wen");
  leg->AddEntry(wmn,"Wmn");
  leg->AddEntry(wtn,"Wtn");
  leg->AddEntry(phomc,"#gamma MC");
  leg->AddEntry(qcd,"QCD");
  if (sumBG) leg->AddEntry(sumBG,"Tot. from Sum BG");
	
	new TCanvas();
	gPad->SetGridx();
	gPad->SetGridy();
	zee->Draw("P");
	zmm->Draw("P SAME");
	ztt->Draw("P SAME");
	wen->Draw("P SAME");
	wmn->Draw("P SAME");
	wtn->Draw("P SAME");
	phomc->Draw("P SAME");
	qcd->Draw("P SAME");
  	if (sumBG) sumBG->Draw("P SAME");
	leg->Draw();	

}

//dumps only one bin content of a hist
void DumpHistBin(TH1* hist, const int bin=0)
{
	assert (hist != NULL && "DumpHistBin:: got null pointer!");

	std::cout << setw(8) << "bin"<< setw(16) << "lo/up edges"<<  setw(8) << "val" << setw(8) << "err" << std::endl; 
	if (bin>=0 && bin <= hist->GetNbinsX())
	{
		std::cout << setw(8) << bin << setw(8) << hist->GetBinLowEdge(bin) 
					<< setw(1) << ", " << setw(4) << hist->GetXaxis()->GetBinUpEdge(bin)
					<< setw(10) << hist->GetBinContent(bin) << ", " << setw(6)
					<< hist->GetBinError(bin) << std::endl;
	}
}

//dumps the all the bin contents of a hist
void Debug_DumpHist(TH1* hist, const int iCallerLine, const int Nbins = 0)
{
	assert (hist != NULL && "Debug_DumpHist:: got null pointer!");
	assert (( hist->GetNbinsX() >= Nbins && Nbins>=0) 
				&& "Debug_DumpHist:: reuested invalid number of Nbins");


	std::cout << __FUNCTION__<<  "::Caller Line#" << iCallerLine;
	if (Nbins>=0)
	{
		std::cout << " - First " << Nbins << " non-zero bins dump for :" << std::endl;
	} else {
		std::cout << " - All non-zero bins dump for :" << std::endl;
	}
	hist->Print();
	std::cout << setw(8) << "bin"<< setw(16) << "lo/up edges"<<  setw(10) 
				 << "val" << setw(10) << "err" << std::endl; 


	for  (int bin=0; bin <= hist->GetNbinsX(); ++bin)
	{
		if (hist->GetBinContent(bin))
		{
			std::cout << setiosflags(ios::fixed) << setprecision(1) 
				<< setw(8) << bin << setw(8) << hist->GetBinLowEdge(bin) 
				<< setw(1) << ", " << setw(4) << hist->GetXaxis()->GetBinUpEdge(bin)
				<< setw(12) << hist->GetBinContent(bin) << ", " << setw(10)
				<< hist->GetBinError(bin) << std::endl;
		}
		//dump all bin if Nbins==0 (default)
		if (bin>=Nbins && Nbins>0) break;
	}
}


//-----------------------------------------------------------------------------
void QuickDebug(const TH1* halojet, const  TH1* zeejet, const TH1* zmmjet,
					const TH1* zttjet, const TH1* wenjet, const 	TH1* wmnjet,
					const TH1* wtnjet, const  TH1* cosmicjet, const  TH1* qcdjet,
					const TH1* mcphojet, const  TH1* qcdjet_100, const  TH1* phojet)
//QuickDebug( halojet,  zeejet, zmmjet, zttjet, wenjet, wmnjet,
					//wtnjet,  cosmicjet,  qcdjet,  mcphojet,  qcdjet_100,  phojet);
{


	assert (halojet != NULL && "halojet hist is null@QuickDebug()");
	//assuming all hists are rebinned (same sizes)
	for (int i=1; i <=halojet->GetNbinsX();++i)
	{
		if (phojet->GetBinContent(i))
		{
			std::cout << "bin " << i << "[" << halojet->GetBinLowEdge(i) << ", " << 
						halojet->GetXaxis()->GetBinUpEdge(i) << "]" << std::endl;
			std::cout <<   " pho jet  [" << phojet->GetBinContent(i) << " / " 
												<< phojet->GetBinError(i) << " / " 
												<< sqrt(phojet->GetBinContent(i))
						<< "]\n qcd100   [" << qcdjet_100->GetBinContent(i) << " / " 
												<< qcdjet_100->GetBinError(i)   << " / " 
												<< sqrt(qcdjet_100->GetBinContent(i))
						<< "]\n mcpho    [" << mcphojet->GetBinContent(i) << " / " 
												<< mcphojet->GetBinError(i)   << " / " 
												<< sqrt(mcphojet->GetBinContent(i))
						<< "]\n qcdjet   [" << qcdjet->GetBinContent(i) << " / " 
												<< qcdjet->GetBinError(i)   << " / " 
												<< sqrt(qcdjet->GetBinContent(i))
						<< "]\n cosmicjet[" << cosmicjet->GetBinContent(i) << " / " 
												<< cosmicjet->GetBinError(i)   << " / " 
												<< sqrt(cosmicjet->GetBinContent(i))
						<< "]\n wtnjet   [" << wtnjet->GetBinContent(i) << " / " 
												<< wtnjet->GetBinError(i)   << " / " 
												<< sqrt(wtnjet->GetBinContent(i))
						<< "]\n wmnjet   [" << wmnjet->GetBinContent(i) << " / " 
												<< wmnjet->GetBinError(i)   << " / " 
												<< sqrt(wmnjet->GetBinContent(i))
						<< "]\n wenjet   [" << wenjet->GetBinContent(i) << " / " 
												<< wenjet->GetBinError(i)   << " / " 
												<< sqrt(wenjet->GetBinContent(i))
						<< "]\n zttjet   [" << zttjet->GetBinContent(i) << " / " 
												<< zttjet->GetBinError(i)   << " / " 
												<< sqrt(zttjet->GetBinContent(i))
						<< "]\n zmmjet   [" << zmmjet->GetBinContent(i) << " / " 
												<< zmmjet->GetBinError(i)   << " / " 
												<< sqrt(zmmjet->GetBinContent(i))
						<< "]\n zeejet   [" << zeejet->GetBinContent(i) << " / " 
												<< zeejet->GetBinError(i)   << " / " 
												<< sqrt(zeejet->GetBinContent(i))
						<< "]\n halojet  [" << halojet->GetBinContent(i) << " / " 
												<< halojet->GetBinError(i)   << " / " 
												<< sqrt(halojet->GetBinContent(i))
						<< "]\n" << std::endl;  
			
			if (i == 9) break;
		}
	}


	assert (phojet != NULL && "cphohist is null");
	
	TH1* chist = (TH1*) halojet->Clone("halojet_copy");
	TH1* cphojet = (TH1*) phojet->Clone("phojet_copy");

	assert (chist != NULL && "chist null!");
	assert (cphojet != NULL && "cphohist is null");
	chist->Add(zeejet,1);
	chist->Add(zmmjet,1);
	chist->Add(zttjet,1);
	chist->Add(wenjet,1);
	chist->Add(wmnjet,1);
	chist->Add(wtnjet,1);
	chist->Add(cosmicjet,1);
	chist->Add(qcdjet,1);
	chist->Add(mcphojet,1);

	cphojet->SetLineColor(kBlue);

	new TCanvas();
	gPad->SetLogy();
	cphojet->Draw();
	chist->Draw("same");
	std::cout << "RETURNING FROM " << __FUNCTION__ << std::endl; 
}

//-----------------------------------------------------------------------------
void DebugQcdMcMix(const TH1* hist_varyMcQcdMix,const TH1* hist_err)
{
	assert (hist_varyMcQcdMix!=NULL && "qcdMcMix hist null");
	assert (hist_err!=NULL && "hist_err hist null");
	
	TH1* hist_mixcp = (TH1*) hist_varyMcQcdMix->Clone("mix_copy");
	TH1* hist_errcp = (TH1*) hist_err->Clone("err_copy");

	
	new TCanvas();
	gPad->SetLogy();
	hist_mixcp->SetTitle("QCD/MC mix DEBUG plot");	
	hist_mixcp->SetMarkerColor(kBlue);
	hist_mixcp->SetLineColor(kBlue);
	hist_errcp->SetLineColor(kRed);
	hist_errcp->SetMarkerColor(kRed);
	hist_mixcp->Draw();
	hist_errcp->Draw("same");
/*	
	for (unsigned bin = 0; bin <= hist_mixcp->GetNbinsX() + 1; ++ bin)
	{
		float value = hist_mixcp->GetBinContent (bin);
		float error = hist_mixcp->GetBinError (bin);
		hist_mixcp->SetBinError (bin, value ? error / value : 0);
		hist_mixcp->SetBinContent (bin, 0);
	};


	
	for (unsigned bin = 0; bin <= hist_errcp->GetNbinsX() + 1; ++ bin)
	{
		const float val = hist_mixcp->GetBinContent (bin);
		const float scale = val ? 1. / val : 0;
		hist_errcp->SetBinContent (bin, (hist_errcp->GetBinContent (bin) - val) * scale);
		hist_errcp->SetBinError (bin, hist_errcp->GetBinError (bin) * scale);
	};


	assert(hist_errcp!=NULL && "hist_err_copy is null");
	new TCanvas();
	gPad->SetTickx();
	gPad->SetTicky();
	gPad->SetGridx();
	gPad->SetGridy();
	hist_errcp->SetFillColor(kRed);
	hist_errcp->SetFillStyle(3002);
	hist_mixcp->SetTitle("QCD/MC mix DEBUG plot");	
	hist_errcp->Draw("same E2");	
*/
}


//-----------------------------------------------------------------------------
// assumes all three hists have a the same bin sizes
void DebugJES(const TH1* hist, const TH1* jesup, const TH1* jesdown,
				 const int iLINE=0, const std::string title="",
				 const std::string filename = "")
{

	assert(hist != NULL && "hist_err null!.");
	assert(jesup != NULL && "jesup null!.");
	assert(jesdown != NULL && "jesdown null!.");

	TH1* chist = (TH1*) hist->Clone("hist_copy");
	TH1* cuhistrat = (TH1*) hist->Clone("hist_copy_uratio");
	TH1* cdhistrat = (TH1*) hist->Clone("hist_copy_dratio");
	TH1* uhist = (TH1*) jesup->Clone("jesup_copy");
	TH1* dhist = (TH1*) jesdown->Clone("jesdown_copy");

	TCanvas *c1 = new TCanvas();
	double w = 1200;
	double h = 600;
	c1->SetCanvasSize(w,h);
	c1->SetWindowSize(w + (w - c1->GetWw()) + 20, h + (h - c1->GetWh())+30);
	c1->Divide(2,1);
	c1->cd(1);
	//gPad->SetLogy();
	gPad->SetTickx();
	gPad->SetTicky();
	gPad->SetGridx();
	gPad->SetGridy();
	chist->SetLineColor(kBlue);
	chist->SetMarkerColor(kBlue);
	chist->SetMarkerStyle (20);
	chist->SetMarkerSize(0.8);
	uhist->SetLineColor(kRed);
	uhist->SetMarkerColor(kRed);
	uhist->SetMarkerStyle (22);
	dhist->SetMarkerStyle (23);
	dhist->SetMarkerColor(kGreen);
	chist->SetMinimum(0.05);
	if (title.length()) chist->SetTitle(title.c_str());
	//find x max ann zoom-in
	double x_max = 0;
	for (int bin=chist->GetNbinsX(); bin>0; --bin)
	{
		if ( chist->GetBinContent(bin) || 
			  uhist->GetBinContent(bin) || 
			  dhist->GetBinContent(bin) )
		{
			x_max = chist->GetXaxis()->GetBinUpEdge(bin);
			break;
		}
	}
	assert (x_max > 0 && "DebugJES:: Max value for X axis retuned zero!");
	
	chist->GetXaxis()->SetRangeUser(0,x_max);
	chist->Draw("P");	
	uhist->Draw("sameP");	
	dhist->Draw("sameP");	

	TLegend *leg = new TLegend (0.7,0.72,0.9,0.9);
	leg->SetTextFont(42);
	leg->SetTextSize(0.03);
	leg->SetBorderSize (1);
	leg->SetFillColor (10);

	leg->AddEntry(chist,"CENTRAL");
	leg->AddEntry(uhist,"JES UP");
	leg->AddEntry(dhist,"JES DOWN");
	//leg->AddEntry(chist,"DATA");
	//leg->AddEntry(uhist,"PHO MC");
	//leg->AddEntry(dhist,"PHO SIDEBAND");
	//leg->AddEntry(chist,"Background");
	//leg->AddEntry(chist,"FakeFrac+#sigma");
	//leg->AddEntry(uhist,"Scaled Pho MC");
	//leg->AddEntry(uhist,"Scaled Sideband");
	//leg->AddEntry(dhist,"PHO SIDEBAND");
	leg->Draw();

	//now make aratio hist of the differeces
	//zero out the two ratio hist (up/down)
	for (int bin=0;bin <= cuhistrat->GetNbinsX()+1; ++bin)
	{
			cuhistrat->SetBinContent(bin, 0);
			cuhistrat->SetBinError(bin, 0);
			cdhistrat->SetBinContent(bin, 0);
			cdhistrat->SetBinError(bin, 0);
	}
	
	
	for (int bin=1; bin <= chist->GetNbinsX(); ++bin)
	{
		if (chist->GetBinContent(bin))
		{
			double cval = chist->GetBinContent(bin);
			double uval = uhist->GetBinContent(bin);
			double dval = dhist->GetBinContent(bin);
			if ( std::isnan(cval) || std::isnan(uval) ||  std::isnan(dval))
			{
				std::cout << __FUNCTION__ << ":" << __LINE__ 
							<< ": one or bin values returned NAN!" << std::endl;
			}
			
			cuhistrat->SetBinContent(bin, uval/cval - 1);
			cdhistrat->SetBinContent(bin, dval/cval - 1);
		}

	}
	
	
	//new TCanvas();
	c1->cd(2);
	gPad->SetTickx();
	gPad->SetTicky();
	gPad->SetGridx();
	gPad->SetGridy();

	cuhistrat->SetMarkerStyle(22);
	cdhistrat->SetMarkerStyle(23);
	cuhistrat->SetMarkerColor(kRed);
	cdhistrat->SetMarkerColor(kGreen);
	
	cuhistrat->SetMinimum (-1.0);
	cuhistrat->SetMaximum (1.0);
	if (title.length()) cuhistrat->SetTitle(title.c_str());
	cuhistrat->GetXaxis()->SetRangeUser(0,x_max);
	cuhistrat->Draw("P");
	cdhistrat->Draw("P SAME");
	leg->Draw();

	c1->cd();
	
	if (filename.length())
	{
		c1->cd();
		c1->Print(filename.c_str());
	}

	//dump first few bins
	std::cout << __FUNCTION__<<  "::Caller Line#" << iLINE<< " - First 4 non-zero bins dump for :" << std::endl;
	std::cout << "CENTRAL - ";
	hist->Print();
	std::cout << "JES UP  - ";
	jesup->Print();
	std::cout << "JES DOWN- ";
	jesdown->Print();
	std::cout << setiosflags(ios::fixed) << setprecision(1) 
		<< setw(4) << "bin " << setw(12) << "lo/up edges" <<  setw(11) << "*central*" 
		<< setw(19) << "*jes up[diff]*" <<  setw(24) << "*jes down [diff]*"
		<< std::endl;
	int dumps = 0;
	for (int bin=1;bin <= chist->GetNbinsX()+1; ++bin)
	{
		if (chist->GetBinContent(bin))
		{
			double cval = chist->GetBinContent(bin);
			double uval = uhist->GetBinContent(bin);
			double dval = dhist->GetBinContent(bin);
			double udiff = cval - uval;
			double ddiff = cval - dval;
			std::cout << setw(4) << bin << setw(6) << hist->GetBinLowEdge(bin) 
				<< setw(1) << ", " << setw(4) << hist->GetXaxis()->GetBinUpEdge(bin)
				<< setw(13) << cval
				<< setw(12) << uval << "[ " << udiff << "]"
				<< setw(12) << dval << "[ " << ddiff << "]"
				<< std::endl;
			++dumps;
		}
		if (dumps>4) break;
	}
}

//-----------------------------------------------------------------------------
//debug only: make a error (ratio hist) with a given set of values
void DebugMakeHist(std::vector<float> contents, const TH1* hist_err ,
					std::string title="DEBUG plot")
{
	assert(hist_err != NULL && "hist is null"); 
	assert((unsigned)contents.size() == (unsigned)hist_err->GetNbinsX() 
					&& "size of contetns does not match Nbins in hist");

	TH1* hist = (TH1*) hist_err->Clone("err_copy");

	for (int i=1; i<=hist->GetNbinsX(); ++i)
	{
		hist->SetBinContent(i,contents.at(i-1));
		hist->SetBinError(i,0);
	}

	new TCanvas();
	hist->SetTitle (title.c_str());
	hist->SetMarkerStyle(kPlus);
	hist->Draw("P");
}



//end for debugging only functions  ------------------------


//-----------------------------------------------------------------------------
/// this generates a TF1 envelop function
TF1* get_error_function (const std::string which, unsigned jets,
								const std::string& sign = "+")
{
	float val0 = 0, val1 = 0, width = 0, power = 2;

	if ((jets==1) && (which=="InvMass")) {
		val0 = 0.15;
		val1 = 1.5;
		width = 1000;
		power = 3.0;
	}
	if ((jets==2) && (which=="InvMass")) {
		val0 = 0.2;
		val1 = 1.2;
		width = 900;
		power = 3.1;
	}
	if ((jets==2) && (which=="PhoJetsInvMass")) {
		val0 = 0.1;
		val1 = 0.8;
		width = 900;
		power = 3.1;
	}

	if ((jets==2) && (which=="JetsInvMass")) {
		val0 = 0.15;
		val1 = 1.4;
		width = 1200;
		power = 3.1;
	}

	if ((jets==1) && (which=="PhotonEt")) {
		val0 = 0.15;
		val1 = 1.5;
		width = 500;
		power = 3.0;
	}

	if ((jets==2) && (which=="PhotonEt")) {
		val0 = 0.14;
		val1 = 1.5;
		width = 500;
		power = 3.0;
	}


	if ((jets==1) && (which=="NJet")) {
		val0 = 0.07;
		val1 = 0.75;
		width = 10;
		power = 2;
	}

	if ((jets==1) && (which=="Ht")) {
		val0 = 0.14;
		val1 = 1.5;
		width = 900;
		power = 3.0;
	}
	if ((jets==2) && (which=="Ht")) {
		val0 = 0.14;
		val1 = 1.5;
		width = 900;
		power = 3.0;
	}

	if ((jets==1 || jets==2) && (which=="LeadJetEt")) {
		val0 = 0.15;
		val1 = 1.5;
		width = 1000;
		power = 3.0;
	}


	if ((jets==1) && (which=="Met")) {
		val0 = 0.14;
		val1 = 1.5;
		width = 900;
		power = 3.0;
	}

	if (width > 0)
	{
		std::ostringstream myname, func;
		myname << "eq_" << jets << which;
		//func << val0 << " + " << (val1 - val0) / pow (width, power) << " *pow(x," << power << ")";
		func << sign << val0 << sign << (val1 - val0) / pow (width, power) << " *pow(x," << power << ")";
		return (new TF1 (myname.str().c_str(), func.str().c_str(), 0, width));
	};
	std::cout << "couldn't find errors for " << which << " " << jets << " jets" << std::endl;
	assert (false);
	return NULL;
};



//-----------------------------------------------------------------------------
//this seems to obsolete. being replaced by get_error_function? - 8-28-2009
TF1* get_fit_function(const std::string which, const TH1* hist,int jets,
							std::string func, float min, float max, int pm=1)
{
	assert (hist != NULL && "hist is a null pointer");

	TH1* test_hist = dynamic_cast<TH1*>(hist->Clone ("fit"));
	for (unsigned bin = 1; bin <= (unsigned) hist->GetNbinsX(); ++ bin)
	{
		test_hist->SetBinContent(bin, pm * hist->GetBinError(bin));
		test_hist->SetBinError(bin, hist->GetBinError(bin)* 0.1);
	}

	test_hist->SetDirectory(0);

	std::cout << " function fit range=" << min << "," << max << std::endl;
	test_hist->Fit(func.c_str(),"","", min, max);
	
	TList *list = test_hist->GetListOfFunctions();
	TIterator *it = list->MakeIterator();
	
	float x_min = test_hist->GetBinLowEdge(1);
	float x_max = test_hist->GetXaxis()->GetXmax();
	

	TF1* tf = new TF1("fit_func",x_min,x_max, 100);
	
	while (tf = (TF1*) it->Next() )
	{
		Double_t p1[5];
		tf->GetParameters(p1);
		if (tf) break;
	}
	
	assert(tf!=NULL && "fit function not found!");
	if (tf) return tf;
}



//-----------------------------------------------------------------------------
void GetCosmicErr(std::vector<float>& ErrVec, const TH1 *hist , bool debug)
{
	if (debug) std::cout << "IN COSMIC ERROR"<< std::endl;
	assert (hist!=NULL && "hist is null");
	for (int i=1; i <= hist->GetNbinsX(); i++) {
		float bin = hist->GetBinContent(i);
		float err = 0;
		if (bin) err = 1 / sqrt(bin);		//take stat error as the syst
		ErrVec.push_back(err);
		if (debug) std::cout << "halo bin[" <<i << "]=" << bin << std::endl;
	}
}

//-----------------------------------------------------------------------------
void GetHaloErr(std::vector<float>& ErrVec, const TH1 *hist, bool debug=false)
{
	assert(hist!=NULL && "hist is null!");
	for (int i=1; i <= hist->GetNbinsX(); i++) {
		float bin = hist->GetBinContent(i);
		float err = bin * 0.5;		//take 50% to be the syst
		ErrVec.push_back(err);
		if (debug) std::cout << "halo err [" << i << "]="<< err <<std::endl;
	}
	if (debug)
	{
		std::cout << "halo err arr size = " << ErrVec.size() << std::endl;
		std::cout << "\n\n\n i am out" << std::endl;
	}
}




//-----------------------------------------------------------------------------
// effects: make a new binning with variable bin sizes, and the given
//   cutoff points between bin sizes
// returns: the binning (by bin edges)
// guarantee: strong
//// throws: std::bad_alloc
//-----------------------------------------------------------------------------
std::vector<float> 
GetVarBinVector (float down, float up5, float up10, float up20, float up50, 
					float width1, float width2, float width3, float width4 ,bool debug)
{
	std::vector<float> result;
	float point = down;
	const unsigned nregion = 4;
	const float up [] = {up5, up10, up20, up50};
	const float step [] = {width1, width2, width3, width4};		//1j pet

	result.push_back (point);
	for (unsigned region = 0; region != nregion; ++ region)
	{
		while (point + step[region] < up[region] + 1)
		{
			point += step[region];
			result.push_back (point);
	 	};
	};
	
	if (point + 1 < up[nregion-1])
		result.push_back (up[nregion-1]);
	
	return result;
};
//-----------------------------------------------------------------------------
// effects: turn this histogram into a histogram with variable bin
//   size
// returns: the new histogram
// guarantee: strong
// throws: std::bad_alloc
// requires: input != NULL
// requires: input->GetDimension() == 1
// requires: histogram bin edges must match
// postcondition: result != NULL
//-----------------------------------------------------------------------------
std::auto_ptr<TH1>
make_var_bin (const std::vector<float>& bins,
	      TH1 *input, bool debug)
{
	assert (input != NULL && "requirement failed"); //spec
	assert (input->GetDimension() == 1 && "requirement failed"); //spec
	const unsigned nbin = unsigned (input->GetNbinsX ());

	std::auto_ptr<TH1> result (new TH1F (input->GetName(), input->GetTitle(),
						 bins.size() - 1, &bins[0]));

	result->SetBinContent (0, input->GetBinContent (0));
	result->SetBinError (0, input->GetBinError (0));
	result->SetBinContent (bins.size(), input->GetBinContent (nbin));
	result->SetBinError (bins.size(), input->GetBinError (nbin));
	for (unsigned bin = 1; bin != nbin; ++ bin)
	{
		const float low = input->GetXaxis()->GetBinLowEdge (bin);
		const float high = input->GetXaxis()->GetBinUpEdge (bin);
		const unsigned bin1 = result->FindBin (0.99 * low + 0.01 * high);
		const unsigned bin2 = result->FindBin (0.01 * low + 0.99 * high);
		assert (bin1 == bin2 && "requirement failed: histogram bin edges don't match"); //spec

		const float va = input->GetBinContent (bin);
		const float ea = input->GetBinError (bin);
		const float vb = result->GetBinContent (bin2);
		const float eb = result->GetBinError (bin2);
		const float vc = va + vb;
		const float ec = sqrt (ea * ea + eb * eb);
		result->SetBinContent (bin2, vc);
		result->SetBinError (bin2, ec);
	};


	if (debug)
	{
		for (unsigned i=1;  i<=(unsigned)input->GetNbinsX (); i++)
		{
			std::cout << "input bin, lowedge = " << i << ", " << input->GetXaxis()->GetBinLowEdge(i) << "\t" << input->GetBinContent(i) << std::endl;
		}
		std::cout << "\n\n"<< std::endl;
		for (unsigned i=1; i<=(unsigned)result->GetNbinsX (); i++)
		{
			std::cout << "otput bin, lowedge = " << i << ", " << result->GetXaxis()->GetBinLowEdge(i) << "\t" << result->GetBinContent(i) << std::endl;
		}
	}

	assert (result.get() != NULL && "postcondition failed"); //spec
	return result;
};

//-----------------------------------------------------------------------------
// effects: normalize each bin by the bin width
// side effect: normalizes histogram bins in hist
// guarantee: no-throw
// requires: hist != NULL
// requires: hist->GetDimension() == 1
//-----------------------------------------------------------------------------
void norm_bins (TH1 *hist)
{
	assert (hist != NULL && "requirement failed"); //spec
	assert (hist->GetDimension() == 1 && "requirement failed"); //spec

	for (unsigned bin = 1; bin != unsigned (hist->GetNbinsX()); ++ bin)
	{
		const float width = hist->GetXaxis()->GetBinWidth (bin);
		hist->SetBinContent (bin, hist->GetBinContent (bin) / width);
		hist->SetBinError (bin, hist->GetBinError (bin) / width);
	};
};

//-----------------------------------------------------------------------------
// make a variable binned hist with given specification
// TESTED THIS METHOD AND ITS SUB-METHODS - sam
//-----------------------------------------------------------------------------
TH1* MakeVariableBins (TH1 *hist, const float xmin, const float xpoint1,
							const float xpoint2, const float xpoint3, const float xpoint4,
				 			const float width1, const float width2, const float width3, 
							const float width4 , bool use_errors=false, bool debug=false)
{
	if (debug)
	{
		std::cout << hist->GetName() << " hist bin size=" << hist->GetBinWidth(1) 
					<< std::endl;
	}

  	std::auto_ptr<TH1> result = make_var_bin ( 
											GetVarBinVector(xmin, xpoint1, xpoint2, 
															xpoint3, xpoint4, width1, 
															width2, width3, width4, debug) , 
											hist, debug);
  	norm_bins (result.get());
  	return result.release ();
};


//-----------------------------------------------------------------------------
//this make the ratio plot and returns the error function (TF1) used for the
//systematics band to the log plot. so the log plot errors will be based
//on this same error function.
//-----------------------------------------------------------------------------
TF1* MakeRatioPlot(const std::string which,  const int jets, const TH1* phojet,
						const TH1* hist_err, std::vector<float> Errors, bool debug=false)
{
	assert(Errors.size() == hist_err->GetNbinsX() && "error and bin number does not match");
	assert(phojet!=NULL && "phojet hist null");
	assert(hist_err!=NULL && "hist_err hist null");

	TH1* pho = (TH1*) phojet->Clone("phojet_copy");
	TH1* err = (TH1*) hist_err->Clone("hist_err_copy");
	
	std::cout << "\n ======= "<< __FUNCTION__ << ":" << __LINE__ << ":" << std::endl;
	std::cout << " ======= Hists given to MakeRatioHist first 4 bins" << std::endl;
	Debug_DumpHist(pho, __LINE__,4);
	Debug_DumpHist(err, __LINE__,4);
	
	for (unsigned bin = 1; bin <= (unsigned)err->GetNbinsX(); ++ bin)
	{
		const float val = err->GetBinContent (bin);
		const float scale = val ? 1. / val : 0;
		pho->SetBinContent (bin, (pho->GetBinContent (bin) - val) * scale);
		pho->SetBinError (bin, pho->GetBinError (bin) * scale);
	};


	std::cout << "\n ======= "<< __FUNCTION__ << ":" << __LINE__ << ":" << std::endl;
	std::cout << " ======= Err hist val and ERROR vector values" << std::endl;
	std::cout << setw(8) << "bin" << setw(10) << "value" << setw(8) << "Error"
			 	<< std::endl; 
	TH1 *hist_err_copy = NULL;
	{
		std::string myname = hist_err->GetName() + std::string ("_copy");
		hist_err_copy = dynamic_cast<TH1*>(hist_err->Clone (myname.c_str()));
		for (unsigned bin = 1; bin <= hist_err_copy->GetNbinsX(); ++ bin)
		{
			float value = hist_err_copy->GetBinContent (bin);
			//float error = hist_err_copy->GetBinError (bin);
			//hist_err_copy->SetBinError (bin, value ? error / value : 0);
			hist_err_copy->SetBinError (bin, value ? Errors.at(bin-1) / value : 0);
			hist_err_copy->SetBinContent (bin, 0);

			std::cout << setiosflags(ios::fixed) << setprecision(1) 
				<< setw(8) << bin << setw(10) << value << setw(8) << Errors.at(bin-1)
			 	<< std::endl; 
		};
	};


	
	//for (unsigned bin = 1; bin <= (unsigned)err->GetNbinsX(); ++ bin)
	
	pho->SetTitle("");
	std::ostringstream ytitle;


	std::string xtitle, yunits;
	if (which =="PhotonEt") { xtitle += "E_{T}^{ #gamma} (GeV)"; yunits= "GeV"; }
	if (jets ==1 && which =="InvMass") { xtitle += "Invariant Mass(#gamma, Lead Jet) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (jets ==2 && which =="InvMass") { xtitle += "Invariant Mass(#gamma, Lead Jet) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (jets ==2 && which =="PhoJetsInvMass") { xtitle += "Invariant Mass(#gamma, Two Lead Jets) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (which =="Ht") xtitle += "H_{T} (GeV)";
	if (which =="JetsInvMass") { xtitle += "Invariant Mass(Two Lead Jets) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (which =="LeadJetEt") xtitle += "E_{T}^{Lead Jet} (GeV)";
	if (which =="SecondLeadJetEt") xtitle += "E_{T}^{Second Lead Jet} (GeV)";
	if (which =="NJet") xtitle += "Jet Multiplicity";
	
	//ytitle << "#frac{Data -- Background}{Background}        Events/"<< phojet->GetBinWidth(1) << " " << yunits;
	ytitle << "Data -- Background / Background";
	//std::cout << "title= " << title << std::endl;
	pho->GetYaxis()->CenterTitle(true);
	pho->GetXaxis()->CenterTitle(true);
	pho->SetTitleOffset(0.9,"Y");
	pho->SetTitleOffset(0.9,"X");
	pho->GetYaxis()->SetTitle(ytitle.str().c_str());
	pho->GetXaxis()->SetTitle(xtitle.c_str());
	pho->SetMinimum (-1.5);
	pho->SetMaximum (1.5);
	pho->SetMarkerStyle(8);
	

	new TCanvas();
	gStyle->SetCanvasColor (10);
	gStyle->SetCanvasBorderSize (0);
	gStyle->SetCanvasBorderMode (0);
				 
	gStyle->SetPadColor (10);
	gStyle->SetFillColor (10);
	gStyle->SetTitleFillColor (10);
	gStyle->SetTitleBorderSize (0);
	gStyle->SetStatColor (10);
	gStyle->SetStatBorderSize (1);

	int labelfont = 10 * 4 + 2;		//10 * fond ID + precision (2 = scalable)
	int titlefont = 10 * 4 + 2;		//10 * fond ID + precision (2 = scalable)
	pho->GetXaxis()->SetLabelFont(labelfont);
	pho->GetYaxis()->SetLabelFont(labelfont);
	pho->GetYaxis()->SetLabelSize(0.05);
	pho->GetXaxis()->SetLabelSize(0.05);
	pho->GetXaxis()->SetTitleFont(titlefont);
	pho->GetYaxis()->SetTitleFont(titlefont);
	pho->GetXaxis()->SetTitleSize(0.05);
	pho->GetYaxis()->SetTitleSize(0.05);
	pho->GetXaxis()->CenterTitle(true);
	pho->GetYaxis()->CenterTitle(true);

	pho->SetMarkerColor(kBlue);
	pho->SetLineColor(kBlue);
	// phojet->GetXaxis()->SetTitle(title.c_str());
	// phojet->GetXaxis()->CenterTitle(true);
  	hist_err_copy->SetFillStyle(3002);
  	hist_err_copy->SetFillColor(kRed);
	
  	TPaveText *tp = new TPaveText(0.5,0.91,0.9,0.99,"NDC");
	tp->SetLineColor(10);
	tp->SetTextFont(titlefont);
	tp->AddText("CDF Run II Preliminary 2.0 fb^{-1}");


	//NOW get a fit function
	std::string func("pol2");
	float min=0, max=1000;
	if (which == "PhotonEt")
	{
		func = "pol3";
		min = 30;
		max= 550;
	}
	if (which == "InvMass") 
	{
		func="pol3";
		min = 50;
		max= 1200;
	}
	if (which == "NJet") 
	{
		func="pol3";
		min = 1;
		max= 10;
	}
	if (which == "JetsInvMass") 
	{
		func="pol3";
		min = 50;
		max= 1200;
	}
	if (which == "PhoJetsInvMass") 
	{
		func="pol3";
		min = 50;
		max= 1200;
	}
	
	//TH1* tt = dynamic_cast<TH1*>(hist_err_copy->Clone("temp"));
	//	tt->SetDirectory(0);
	//TF1 *tf  = get_fit_function(which, tt, jets, func, min, max, 1);
	//TF1 *tf2 = get_fit_function(which, tt, jets, func, min, max, -1);
  	TF1* tf = get_error_function (which, jets, "+");
  	TF1* tf2 = get_error_function (which, jets, "-");


	new TCanvas();
	gPad->UseCurrentStyle();
	gPad->SetTickx();
	gPad->SetTicky();
	gPad->SetGridx();
	gPad->SetGridy();


	TLegend *leg = new TLegend (0.1,0.72,0.41,0.9);
	leg->SetTextFont(42);
	leg->SetTextSize(0.03);
	leg->SetBorderSize (1);
	leg->SetFillColor (10);

	std::string lbl;
	if (jets == 1) lbl = "Data (#gamma +>=1 Jet)";
	if (jets == 2) lbl = "Data (#gamma +>=2 Jets)";

	leg->AddEntry(pho,lbl.c_str());
	leg->AddEntry(hist_err_copy,"Systematic Uncertainty");
	//leg->AddEntry(tf,"Envelop for systematic");
	//leg->AddEntry(tf,"Systematic Uncertainty");

	//trying to fill the area between fit functions. the TF1::Draw("FC") does not work in this case for some reason
	//	for (unsigned bin = 1; bin <= hist_err_copy->GetNbinsX(); ++ bin)
	//	{
	//		hist_err_copy->SetBinError (bin, tf->Eval(hist_err_copy->GetBinCenter(bin)));
	//	};

	int more = 1;
	if (which =="NJet") more =10;
	TH1F* temp = new TH1F("fit_1","fit+",(max-min)*more ,min, max);
		for (unsigned bin = 1; bin <= temp->GetNbinsX(); ++ bin)
		{
			temp->SetBinError (bin, tf->Eval(temp->GetBinCenter(bin)));
			temp->SetBinContent (bin,0);
		};

  	temp->SetFillStyle(3002);
  	temp->SetFillColor(kRed);
	hist_err_copy->SetLineColor(10);

	pho->Draw();
	//below is the hist that draws the envelop using the ploynomial
	hist_err_copy->Draw ("SAME E2");
	//std::cout << __FUNCTION__ << ":" << __LINE__ << ":: hist_err_copy dump" << std::endl;
	
	/*tf->SetFillColor(kRed);
	tf2->SetFillColor(kRed);
	tf->SetLineColor(kRed);
	tf2->SetLineColor(kRed);
	tf->SetLineWidth(0.75);
	tf2->SetLineWidth(0.75);
	tf->Draw("FCsame");
	tf2->Draw("sameFC");
	*/
	leg->Draw();
	tp->Draw();
	//temp->Draw("same E2");

	TCanvas *c = dynamic_cast<TCanvas*>(gPad);
	if (c)
	{
		//c->SetFillColor(kRed);
		std::ostringstream str,str1,str2;
		str << "ratioplot" << jets << "_" << which << ".gif";
		//c->Print (str.str().c_str());
		str1 << "ratioplot" << jets << "_" << which << ".pdf";
		//c->Print (str1.str().c_str(),"pdf");
		str2 << "ratioplot" << jets << "_" << which << ".eps";
		//c->Print (str2.str().c_str(),"eps");

	};

	assert(tf!=NULL && "fit function retuned NULL");
	return tf;
}





//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
float GetMax(const float def, const float up, const float down)
/*{{{*/
{
	float m1 = fabs(def - up);
	float m2 = fabs(def - down);
	if (m1>m2) return m1;
	else return m2;
}
/*}}}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
float GetMax(const float x1, const float x2, const float x3, const float x4)
/*{{{*/
{
	float max1 = 0, max2 =0;
	
	if (x1>x2) max1 = x1;
	else max1 = x2;
	
	if (x3>x4) max2 = x3;
	else max2 = x4;

	if (max1 > max2) return max1;
	else return max2;
}
/*}}}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void GetQCD100Err(std::vector<float>& ErrVec, const TH1* qcdhist, const std::string name,
						const std::string abspath, const float xmin, const float xpoint1,
							const float xpoint2, const float xpoint3, const float xpoint4,
				 			const float width1, const float width2, const float width3, 
							const float width4, bool debug=false)
{
	std::cout << "NOT TESTED COMPLETELY !!!!!!!!!!!!!!!" << std::endl;
	std::string hademfile("Systematics_TightHadEm.root");
	std::string isofile("Systematics_TightIso.root");
	std::string trkptfile("Systematics_TightTrkPt.root");
	std::string trkisofile("Systematics_TightTrkIso.root");
	
	TFile* fhadem = new TFile(hademfile.c_str());
	TFile* fiso = new TFile(isofile.c_str());
	TFile* ftrkpt = new TFile(trkptfile.c_str());
	TFile* ftrkiso = new TFile(trkisofile.c_str());
	
	if (fhadem->IsZombie()) { std::cout  << hademfile << "file not found" <<std::endl; return;}
	if (fiso->IsZombie()) { std::cout  << isofile << "file not found" <<std::endl; return;}
	if (ftrkpt->IsZombie()) { std::cout  << trkptfile << "file not found" <<std::endl; return;}
	if (ftrkiso->IsZombie()) { std::cout  << trkisofile << "file not found" <<std::endl; return;}


	std::cout << abspath << std::endl;
			
	fhadem->cd();
	if (! gDirectory->cd(abspath.c_str())) {
		std::cout << "path not found :" << abspath <<std::endl;
		return;
	}
	
	TH1F* hademhist = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	if (! hademhist){
		std::cout << __LINE__ << " ::hist not found in the dir" <<std::endl;
		return;
	}

	fiso->cd();
		gDirectory->cd(abspath.c_str());
		TH1F* isohist = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	ftrkpt->cd();
		gDirectory->cd(abspath.c_str());
		TH1F* trkpthist = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	ftrkiso->cd();
		gDirectory->cd(abspath.c_str());
		TH1F* trkisohist = (TH1F*) gDirectory->FindObjectAny(name.c_str());

   hademhist  = (TH1F*) MakeVariableBins (hademhist, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false); 
   isohist    = (TH1F*) MakeVariableBins (isohist, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);  
   trkpthist  = (TH1F*) MakeVariableBins (trkpthist, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);  
   trkisohist = (TH1F*) MakeVariableBins (trkisohist, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);  

	hademhist->Scale(qcdhist->Integral()/hademhist->Integral());
	isohist->Scale(qcdhist->Integral()/isohist->Integral());
	trkpthist->Scale(qcdhist->Integral()/trkpthist->Integral());
	trkisohist->Scale(qcdhist->Integral()/trkisohist->Integral());

	hademhist->Divide(qcdhist);
	isohist->Divide(qcdhist);
	trkpthist->Divide(qcdhist);
	trkisohist->Divide(qcdhist);
	
	if (debug)
	{
		hademhist->SetMaximum(10);
		isohist->SetLineColor(kRed);
		trkpthist->SetLineColor(kBlue);
		trkisohist->SetLineColor(kGreen);
		hademhist->SetMarkerStyle(1);
		isohist->SetMarkerStyle(2);
		trkpthist->SetMarkerStyle(3);
		trkisohist->SetMarkerStyle(4);

		new TCanvas();
		gPad->SetGridx();
		gPad->SetGridy();
		hademhist->Draw("P");
		isohist->Draw("sameP");
		trkpthist->Draw("sameP");
		trkisohist->Draw("sameP");
	}
	return;

	//now find the max for each bin
	for (int i=1; i <= qcdhist->GetNbinsX(); i++) {
		// i do not need to worry about values below 1, as there will be none.
		// each additional cut will give you always equal or lesser number of events.
		// hence all hist values will be above 1.
		float max = GetMax(hademhist->GetBinContent(i),
									isohist->GetBinContent(i),
									trkpthist->GetBinContent(i),
									trkisohist->GetBinContent(i));
		float err = fabs(max -1) * qcdhist->GetBinContent(i);
		ErrVec.push_back(err);
	}

}




void MakeHistLogAndRatio (std::string which, const int jets, 
					const std::string name,const std::string title,
				 	const std::string path, const int QCDerrMtd,
				 	const float xmin, const float xpoint1, 
					const float xpoint2, const float xpoint3, 
					const float xpoint4, const float width1, 
					const float width2, const float width3, 
					const float width4)
{

	//the string 'which' will be used to identify hists with same name
	// for eg: Photon Et has the name EtCorr
	// and so does the Lead jet Et, and so on..
	// if which=="Photon" (with jets==1) -> Photon EtCorr of photon+1jet
	// if which=="Lead Jet" (with jets==1) -> Lead Jet EtCorr of photon+1jet
	// if which=="Photon" (with jets==2) -> Photon EtCorr of photon+2jet
	// if which=="Lead Jet" (with jets==2) -> Lead Jet EtCorr of photon+2jet
	// if which=="Second Lead Jet" (with jets==2) -> Second Lead Jet EtCorr of photon+2jet
	// same for Inv Mass
	
	
  std::string phofile("PhoJets_data.root");
  std::string mcphofile("PhoJets_phomc.root");
  std::string zeefile("PhoJets_zeemc.root");
  std::string zmmfile("PhoJets_zmmmc.root");
  std::string zttfile("PhoJets_zttmc.root");
  std::string wenfile("PhoJets_wenmc.root");
  std::string wmnfile("PhoJets_wmnmc.root");
  std::string wtnfile("PhoJets_wtnmc.root");
 
 
  TFile* fpho = new TFile(phofile.c_str());
  TFile* fmcpho = new TFile(mcphofile.c_str());
  TFile* fzee = new TFile(zeefile.c_str());
  TFile* fzmm = new TFile(zmmfile.c_str());
  TFile* fztt = new TFile(zttfile.c_str());
  TFile* fwen = new TFile(wenfile.c_str());
  TFile* fwmn = new TFile(wmnfile.c_str());
  TFile* fwtn = new TFile(wtnfile.c_str());


  if (fpho->IsZombie() ||fmcpho->IsZombie() ||
      fzee->IsZombie() ||fzmm->IsZombie() ||
      fztt->IsZombie() ||fwen->IsZombie() ||
      fwmn->IsZombie() ||fwtn->IsZombie() ) 
	{
		std::cout  << "a file not found. pl check" <<std::endl; return;
	}

  // ok path :1Jet/Photon/
  std::string sHaloDir     ("Hist/HALO/"     + path);
  std::string sCosmicDir   ("Hist/COSMIC/"   + path);
  std::string sQcdDir      ("Hist/SIDEBAND/" + path);
  std::string sSigDir      ("Hist/SIGNAL/"   + path);
  std::string sMcCentralDir("Hist/CENTRAL/"  + path);
  std::string sMcUpDir     ("Hist/EMJESUP/"  + path);
  std::string sMcDownDir   ("Hist/EMJESDOWN/"+ path);



	fpho->cd();
	std::cout << "path="<<path<< std::endl;
	std::cout << "dir="<<sSigDir<< std::endl;

	if (! gDirectory->cd(sSigDir.c_str())) {
	 std::cout << "path not found "<< std::endl;
	 return;
	}
	
	TH1F* phojet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	if (! phojet){
	 std::cout << "hist not found in the dir" <<std::endl;
	 return;
	}
			
	gDirectory->pwd();
	fpho->cd();
	gDirectory->cd(sHaloDir.c_str());
	gDirectory->pwd();
	TH1F* halojet = (TH1F*) gDirectory->FindObjectAny(name.c_str());

	fpho->cd();
	gDirectory->cd(sCosmicDir.c_str());
	gDirectory->pwd();
	TH1F* cosmicjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());

	fpho->cd();
	gDirectory->cd(sQcdDir.c_str());
	gDirectory->pwd();
	TH1F* qcdjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());			//for QCD+MC combined method
	TH1F* qcdjet_100 = (TH1F*) qcdjet->Clone("qcdjet_100");						// for 100% QCD method


	//MC HISTS: jesup= jesup && emup : jesdown = jesdown && emdown

	fmcpho->cd();
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* mcphojet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fmcpho->cd();
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* mcphojetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fmcpho->cd();
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* mcphojetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			

	fzee->cd();		
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* zeejet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fzee->cd();		
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* zeejetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fzee->cd();		
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* zeejetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			
	fzmm->cd();		
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* zmmjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fzmm->cd();		
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* zmmjetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fzmm->cd();		
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* zmmjetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			
	fztt->cd();		
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* zttjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fztt->cd();		
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* zttjetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fztt->cd();		
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* zttjetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			
	fwen->cd();		
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* wenjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fwen->cd();		
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* wenjetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fwen->cd();		
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* wenjetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			
	fwmn->cd();		
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* wmnjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fwmn->cd();		
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* wmnjetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fwmn->cd();		
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* wmnjetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			
	fwtn->cd();		
	gDirectory->cd(sMcCentralDir.c_str());
	TH1F* wtnjet = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fwtn->cd();		
	gDirectory->cd(sMcUpDir.c_str());
	TH1F* wtnjetJESUP = (TH1F*) gDirectory->FindObjectAny(name.c_str());
	fwtn->cd();		
	gDirectory->cd(sMcDownDir.c_str());
	TH1F* wtnjetJESDOWN = (TH1F*) gDirectory->FindObjectAny(name.c_str());
			
			

	std::cout << "\n -------------- " << __FUNCTION__ << ":" << __LINE__ << " : hists before rebinning only" << std::endl;
	//QuickDebug( halojet,  zeejet, zmmjet, zttjet, wenjet, wmnjet,
	//				wtnjet,  cosmicjet,  qcdjet,  mcphojet,  qcdjet_100,  phojet);

	
	gStyle->SetOptStat(0);

	//Debug_DumpHist(phojet);
/*
	phojet->Sumw2();
	halojet->Sumw2();
	zeejet->Sumw2();
	zmmjet->Sumw2();
	zttjet->Sumw2();
	wenjet->Sumw2();
	wmnjet->Sumw2();
	wtnjet->Sumw2();
	cosmicjet->Sumw2();
	qcdjet->Sumw2();
	mcphojet->Sumw2();
	qcdjet_100->Sumw2();

  	zeejetJESUP->Sumw2();
  	zmmjetJESUP->Sumw2();
  	zttjetJESUP->Sumw2();
  	wenjetJESUP->Sumw2();
  	wmnjetJESUP->Sumw2();
  	wtnjetJESUP->Sumw2();
  	mcphojetJESUP->Sumw2();

  	zeejetJESDOWN->Sumw2();
  	zmmjetJESDOWN->Sumw2();
  	zttjetJESDOWN->Sumw2();
  	wenjetJESDOWN->Sumw2();
  	wmnjetJESDOWN->Sumw2();
  	wtnjetJESDOWN->Sumw2();
  	mcphojetJESDOWN->Sumw2();
*/


	
  	phojet = (TH1F*) MakeVariableBins (phojet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	halojet = (TH1F*) MakeVariableBins (halojet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zeejet = (TH1F*) MakeVariableBins (zeejet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zmmjet = (TH1F*) MakeVariableBins (zmmjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zttjet = (TH1F*) MakeVariableBins (zttjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wenjet = (TH1F*) MakeVariableBins (wenjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wmnjet = (TH1F*) MakeVariableBins (wmnjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wtnjet = (TH1F*) MakeVariableBins (wtnjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	cosmicjet = (TH1F*) MakeVariableBins (cosmicjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	qcdjet = (TH1F*) MakeVariableBins (qcdjet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	mcphojet = (TH1F*) MakeVariableBins (mcphojet, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	qcdjet_100 = (TH1F*) MakeVariableBins (qcdjet_100, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);

  	zeejetJESUP = (TH1F*) MakeVariableBins (zeejetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zmmjetJESUP = (TH1F*) MakeVariableBins (zmmjetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zttjetJESUP = (TH1F*) MakeVariableBins (zttjetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wenjetJESUP = (TH1F*) MakeVariableBins (wenjetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wmnjetJESUP = (TH1F*) MakeVariableBins (wmnjetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wtnjetJESUP = (TH1F*) MakeVariableBins (wtnjetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	mcphojetJESUP = (TH1F*) MakeVariableBins (mcphojetJESUP, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);

  	zeejetJESDOWN = (TH1F*) MakeVariableBins (zeejetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zmmjetJESDOWN = (TH1F*) MakeVariableBins (zmmjetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	zttjetJESDOWN = (TH1F*) MakeVariableBins (zttjetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wenjetJESDOWN = (TH1F*) MakeVariableBins (wenjetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wmnjetJESDOWN = (TH1F*) MakeVariableBins (wmnjetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	wtnjetJESDOWN = (TH1F*) MakeVariableBins (wtnjetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);
  	mcphojetJESDOWN = (TH1F*) MakeVariableBins (mcphojetJESDOWN, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true, false);

	//for debug only
	
	//DebugStatErr(zeejet, zmmjet, zttjet, wenjet, wmnjet, wtnjet,qcdjet,  mcphojet);
	DebugTwoHistRatio(qcdjet,mcphojet);
	
	/*
	mcphojet->Scale(1.0/(1.0* mcphojet->Integral()));
	qcdjet->Scale(1.0/(1.0* qcdjet->Integral()));
	phojet->Scale(1.0/(1.0* phojet->Integral()));
	DebugJES(phojet,mcphojet,qcdjet,__LINE__,"E_{T}^{Lead jet} : DATA/SIDEBAND/PHO MC each normalized to unity after rebining");
	return;
	*/
	//end debug stuff

	std::cout << __LINE__ << " : " << __FUNCTION__ << " ==================== AFTER REBIN ===  "<< std::endl;

/*	std::cout << __LINE__ << ":: DATA HISTS after rebinning " << std::endl;
	Debug_DumpHist(phojet,__LINE__,5);
	std::cout << __LINE__ << ":: QCD HISTS after rebinning " << std::endl;
	Debug_DumpHist(qcdjet,__LINE__,5);
	std::cout << __LINE__ << ":: QCD 100% HISTS after rebinning " << std::endl;
	Debug_DumpHist(qcdjet_100,__LINE__,5);
	std::cout << __LINE__ << ":: MC PHO HISTS after rebinning " << std::endl;
	DebugJES(mcphojet,mcphojetJESUP, mcphojetJESDOWN,__LINE__, "#gamma MC - after rebining", "PhoMC_afterRebining.gif");
	std::cout << __LINE__ << ":: Zee HISTS after rebinning " << std::endl;
	DebugJES(zeejet, zeejetJESUP, zeejetJESDOWN, __LINE__, "Zee MC - after rebining", "ZeeMC_afterRebining.gif");
	std::cout << __LINE__ << ":: Zmm HISTS after rebinning " << std::endl;
	DebugJES(zmmjet, zmmjetJESUP, zmmjetJESDOWN, __LINE__, "Zmm MC - after rebining", "ZmmMC_afterRebining.gif");
	std::cout << __LINE__ << ":: Ztt HISTS after rebinning " << std::endl;
	DebugJES(zttjet, zttjetJESUP, zttjetJESDOWN, __LINE__, "Ztt MC - after rebining", "ZttMC_afterRebining.gif");
	std::cout << __LINE__ << ":: Wen HISTS after rebinning " << std::endl;
	DebugJES(wenjet, wenjetJESUP, wenjetJESDOWN, __LINE__, "Wen MC - after rebining", "WenMC_afterRebining.gif");
	std::cout << __LINE__ << ":: Wmn HISTS after rebinning " << std::endl;
	DebugJES(wmnjet, wmnjetJESUP, wmnjetJESDOWN, __LINE__, "Wmn MC - after rebining", "WmnMC_afterRebining.gif");
	std::cout << __LINE__ << ":: Wtn HISTS after rebinning " << std::endl;
	DebugJES(wtnjet, wtnjetJESUP, wtnjetJESDOWN, __LINE__, "Wtn MC - after rebining", "WtnMC_afterRebining.gif");
*/
	
	//TESTED UP TO THIS POINT - SAM
	//std::cout << "\n -------------- " << __FUNCTION__ << ":" << __LINE__ << " : hists after rebinning only" << std::endl;
	//Debug_DumpHist(phojet);
	//QuickDebug( halojet,  zeejet, zmmjet, zttjet, wenjet, wmnjet,
	//				wtnjet,  cosmicjet,  qcdjet,  mcphojet,  qcdjet_100,  phojet);

	//

/************** FAKE PHOTON FRACTION ************************************/
	//this is used when the combination of QCD+PHO MC is used
  //fake photon fraction = 0.319+/-0.068(syst)
  // this is the amount of fake photons in the signal we select(jets faking photon) which is ~30%
  float fake_pho_frac_d = 0.319;
  float fake_pho_frac_sigma = 0.068;
  float fake_pho_frac_p = fake_pho_frac_d + fake_pho_frac_sigma;
  //float fake_pho_frac_m = fake_pho_frac_d - fake_pho_frac_sigma;
  
  float qcd_d = 0.319;			//mean
  //float qcd_m = 0.251;			//mean+sigma
  //float qcd_p = 0.387;			//mean-sigma

  float qcd_scale = qcd_d;					//these background need to be scaled to these values
  float phomc_scale  = 1 - qcd_d;

  std::string qcd_str, mc_str;
  std::ostringstream qcdnum, mcnum;
  qcdnum << "QCD (#gamma sideband, " << qcd_scale<< " of data)";
  mcnum << "#gamma MC (" << phomc_scale << " of data)";
  qcd_str = qcdnum.str();		// to be used in the legend of the final plot
  mc_str = mcnum.str();

	/************************************************************************/
  //******************* NORMALIZING *************************************
	float haloEst 		= 0;
	float cosmicEst 	= 0;
	if (jets ==1 ) {
		haloEst = 9;				//these estimates are for the full dataset
		cosmicEst = 110;
	} else if (jets ==2 ) {
		haloEst = 1 ;
		cosmicEst = 7 ;
	} else {
		std::cout << __FILE__ <<"::"<<__LINE__<<":: Invalid number of jets !" << std::endl;
		exit (1);
	}

	float haloNorm   = 0;
	float cosmicNorm = 0;
	float qcdNorm    = 0; 
	float mcphoNorm  = 0;
	float qcd100Norm = 0;		//for the plots that we use 100% of QCD sideband

	haloNorm    = haloEst / halojet->Integral();
	cosmicNorm  = cosmicEst / cosmicjet->Integral();
	qcdNorm     = (phojet->Integral() * qcd_scale) / qcdjet->Integral();
	qcd100Norm  = phojet->Integral() / qcdjet_100->Integral(); 
	mcphoNorm   = (phojet->Integral() * phomc_scale) / mcphojet->Integral();


	//JES PHO MC
	float mcphoJESUPNorm = ((phojet->Integral()) * phomc_scale)/mcphojetJESUP->Integral();
	float mcphoJESDOWNNorm = ((phojet->Integral()) * phomc_scale)/mcphojetJESDOWN->Integral();

	float dataLum=2043.0;	//pb-1

	float kFac = 1.4;
	// SF = DATA_LUM * ( 1 / EWK_LUM ) * KFAC
	//    = DATA_LUM * ( 1 / (TOT EVTS PROCESSED/CROSS SECTION) ) * KFAC
	//    here are the values picked up from pp.102
	//    DATASET   TOTAL EVTS   CROSSSECTION   LUM == TOTAL EVTS/CROSSSECTION
	//    Zee       12,092,155    355pb          34062 pb-1
	//    Zmm       13,755,133    355pb          38746 pb-1
	//    Ztt       

	float zeenorm = (dataLum/34056)*kFac;    // for EWK mc see. log book#2 pp.72 (old) pp.102 (new)
	float zmmnorm = (dataLum/38732)*kFac;    // for EWK mc see. log book#2 pp.72 (old) pp.102 (new)
	float zttnorm = (dataLum/27755)*kFac;    // for EWK mc see. log book#2 pp.72 (old) pp.102 (new)
	float wennorm = (dataLum/9438)*kFac;     // for EWK mc see. log book#2 pp.72 (old) pp.102 (new)
	float wmnnorm = (dataLum/5183)*kFac;     // for EWK mc see. log book#2 pp.72 (old) pp.102 (new)
	float wtnnorm = (dataLum/3520)*kFac;     // for EWK mc see. log book#2 pp.72 (old) pp.102 (new)

	
	halojet->Scale (haloNorm);
	cosmicjet->Scale (cosmicNorm);
	qcdjet->Scale (qcdNorm);
	qcdjet_100->Scale (qcd100Norm);
	mcphojet->Scale (mcphoNorm);
	zeejet->Scale (zeenorm);
	zmmjet->Scale (zmmnorm);
	zttjet->Scale (zttnorm);
	wenjet->Scale (wennorm);
	wmnjet->Scale (wmnnorm);
	wtnjet->Scale (wtnnorm);

	
	// JES 
	mcphojetJESUP->Scale (mcphoJESUPNorm);
	zeejetJESUP->Scale (zeenorm);
	zmmjetJESUP->Scale (zmmnorm);
	zttjetJESUP->Scale (zttnorm);
	wenjetJESUP->Scale (wennorm);
	wmnjetJESUP->Scale (wmnnorm);
	wtnjetJESUP->Scale (wtnnorm);

	mcphojetJESDOWN->Scale (mcphoJESDOWNNorm);
	zeejetJESDOWN->Scale (zeenorm);
	zmmjetJESDOWN->Scale (zmmnorm);
	zttjetJESDOWN->Scale (zttnorm);
	wenjetJESDOWN->Scale (wennorm);
	wmnjetJESDOWN->Scale (wmnnorm);
	wtnjetJESDOWN->Scale (wtnnorm);


	//for debugging
	/// stopped here
	
	
	std::cout << __LINE__ << " : " << __FUNCTION__ <<  "======== AFTER SCALING " << std::endl;
	/*Debug_DumpHist(phojet,__LINE__,5);
	std::cout << __LINE__ << ":: QCD HISTS after rebinning " << std::endl;
	Debug_DumpHist(qcdjet,__LINE__,5);
	std::cout << __LINE__ << ":: QCD 100% HISTS after rebinning " << std::endl;
	Debug_DumpHist(qcdjet_100,__LINE__,5);
	std::cout << __LINE__ << ":: MC PHO HISTS after scaling " << std::endl;
	DebugJES(mcphojet,mcphojetJESUP, mcphojetJESDOWN,__LINE__, "#gamma MC - after scaling", "PhoMC_afterScaling.gif");
	std::cout << __LINE__ << ":: Zee HISTS after scaling " << std::endl;
	DebugJES(zeejet, zeejetJESUP, zeejetJESDOWN, __LINE__, "Zee MC - after scaling", "ZeeMC_afterScaling.gif");
	std::cout << __LINE__ << ":: Zmm HISTS after scaling " << std::endl;
	DebugJES(zmmjet, zmmjetJESUP, zmmjetJESDOWN, __LINE__, "Zmm MC - after scaling", "ZmmMC_afterScaling.gif");
	std::cout << __LINE__ << ":: Ztt HISTS after scaling " << std::endl;
	DebugJES(zttjet, zttjetJESUP, zttjetJESDOWN, __LINE__, "Ztt MC - after scaling", "ZttMC_afterScaling.gif");
	std::cout << __LINE__ << ":: Wen HISTS after scaling " << std::endl;
	DebugJES(wenjet, wenjetJESUP, wenjetJESDOWN, __LINE__, "Wen MC - after scaling", "WenMC_afterScaling.gif");
	std::cout << __LINE__ << ":: Wmn HISTS after scaling " << std::endl;
	DebugJES(wmnjet, wmnjetJESUP, wmnjetJESDOWN, __LINE__, "Wmn MC - after scaling", "WmnMC_afterScaling.gif");
	std::cout << __LINE__ << ":: Wtn HISTS after scaling " << std::endl;
	DebugJES(wtnjet, wtnjetJESUP, wtnjetJESDOWN, __LINE__, "Wtn MC - after scaling", "WtnMC_afterScaling.gif");
*/
	
	std::cout << "\n" << std::endl; 
	std::cout << __LINE__ << ":: ALL  HISTS after scaling " << std::endl;
	std::cout << __LINE__ << ":: halojet Integral    =  " << halojet->Integral() << std::endl;
	std::cout << __LINE__ << ":: cosmicjet Integral  =  " << cosmicjet->Integral() << std::endl;
	std::cout << __LINE__ << ":: qcdjet Integral     =  " << qcdjet->Integral() << std::endl;
	std::cout << __LINE__ << ":: qcdjet_100 Integral =  " << qcdjet_100->Integral() << std::endl;
	std::cout << __LINE__ << ":: mcphojet Integral   =  " << mcphojet->Integral() << std::endl;
	std::cout << __LINE__ << ":: zeejet Integral     =  " << zeejet->Integral() << std::endl;
	std::cout << __LINE__ << ":: zmmjet Integral     =  " << zmmjet->Integral() << std::endl;
	std::cout << __LINE__ << ":: zttjet Integral     =  " << zttjet->Integral() << std::endl;
	std::cout << __LINE__ << ":: wenjet Integral     =  " << wenjet->Integral() << std::endl;
	std::cout << __LINE__ << ":: wmnjet Integral     =  " << wmnjet->Integral() << std::endl;
	std::cout << __LINE__ << ":: wtnjet Integral     =  " << wtnjet->Integral() << std::endl;

	//return;

	// end debug stuff
	
  //***************END  NORMALIZING *************************************
 //*************** SUBTRACT HALO/COSMIC/EWK FROM QCD BACKGROUND *******
  // this will avoid the double counting
  //I have removed halo/cosmics from both signal and qcd templates,
  // I need to subtract the templates by normalizing them to signal/qcd.
  //but since I have an estimate of the expected number of halo/cosmics 
  // events, I can just subtract the template. halo selection is orthogonal to 
  // photon or qcd selection. cosmic fraction in signal/qcd can be asumed to
  // be same, I think.
  
  qcdjet->Add(cosmicjet, -1);
  qcdjet->Add(halojet, -1);
  qcdjet_100->Add(halojet, -1);
  qcdjet_100->Add(cosmicjet, -1);

  qcdjet->Add(zeejet, -1);
  qcdjet->Add(zmmjet, -1);
  qcdjet->Add(zttjet, -1);
  qcdjet->Add(wenjet, -1);
  qcdjet->Add(wmnjet, -1);
  qcdjet->Add(wtnjet, -1);

  qcdjet_100->Add(zeejet, -1);
  qcdjet_100->Add(zmmjet, -1);
  qcdjet_100->Add(zttjet, -1);
  qcdjet_100->Add(wenjet, -1);
  qcdjet_100->Add(wmnjet, -1);
  qcdjet_100->Add(wtnjet, -1);

  //*********************************************************************

	//****************** SYSTEMATICS *************************************

  std::vector<float> cosmicErr;   //relative error for each bin is stored here
  std::vector<float> haloErr;

  GetCosmicErr(cosmicErr, cosmicjet, false);
  GetHaloErr(haloErr, halojet);

	// Luminosity Error +/-6%
  float fact = fabs(1.0-100.0/106.0);
  float zeeLumErr = zeenorm * fact;
  float zmmLumErr = zmmnorm * fact;
  float zttLumErr = zttnorm * fact;
  float wenLumErr = wennorm * fact;
  float wmnLumErr = wmnnorm * fact;
  float wtnLumErr = wtnnorm * fact;


	// JES and QCD mixture 
	// here I am trying to get two things done at once. 1. JES syst 2. fake pho fraction syste using pho mc and qcd

	TH1F *hist_err = (TH1F*) halojet->Clone("hist_err");					//central values and use for SYSTEMATIC ERROR BAND
  																							// this must be identical to the final stacked plot
	TH1F *hist_jesup = (TH1F*) halojet->Clone("hist_err_jesup");			//sum of em/jes up plots, just like the sum of central plots
  	TH1F *hist_jesdown = (TH1F*) halojet->Clone("hist_err_jesdown"); 	//sum of em/jes down plots
  
	hist_err->Add(zeejet);
	hist_err->Add(zmmjet);
	hist_err->Add(zttjet);
	hist_err->Add(wmnjet);
	hist_err->Add(wenjet);
	hist_err->Add(wtnjet);
	hist_err->Add(cosmicjet);

	hist_jesup->Add(zeejetJESUP);
	hist_jesup->Add(zmmjetJESUP);
	hist_jesup->Add(zttjetJESUP);
	hist_jesup->Add(wenjetJESUP);
	hist_jesup->Add(wmnjetJESUP);
	hist_jesup->Add(wtnjetJESUP);
	hist_jesup->Add(cosmicjet);

	hist_jesdown->Add(zeejetJESDOWN);
	hist_jesdown->Add(zmmjetJESDOWN);
	hist_jesdown->Add(zttjetJESDOWN);
	hist_jesdown->Add(wenjetJESDOWN);
	hist_jesdown->Add(wmnjetJESDOWN);
	hist_jesdown->Add(wtnjetJESDOWN);
	hist_jesdown->Add(cosmicjet);

	std::vector<float> qcdmcMixErr;		//this will hold the systematics for either QCD mthd 1 or 2 for a given case
	TH1F* hist_qcd100Syst;					//to get systematics when 100% QCD is used
 	TH1F* hist_varyMcQcdMixSyst;			// this will be used to get the systematic error in the fake photon fraction
												// when I use the QCD+MC combination
												// I need a copy of the central hists before the qcd+mc (central) is added

	if (QCDerrMtd == 1)		//_______________________ plots that use 100% qcd
  	{
  		hist_qcd100Syst = (TH1F*) hist_err->Clone("hist_qcd100");

		hist_err->Add(qcdjet_100);
		hist_jesup->Add(qcdjet_100);
		hist_jesdown->Add(qcdjet_100);
	
    	std::string abspath("Hist/"+path);
	   GetQCD100Err(qcdmcMixErr, hist_qcd100Syst, name, abspath, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, false);
		
 	
	} else if (QCDerrMtd == 2)  //_____________________ plots that use 30%70%
	{
  		hist_varyMcQcdMixSyst = (TH1F*) hist_err->Clone("hist_varyMcQcdMixSyst");	//use this to get a varied mix of qcd+pho mc
		
		hist_err->Add(qcdjet);
		hist_err->Add(mcphojet);
 
		hist_jesup->Add(qcdjet);
		hist_jesup->Add(mcphojetJESUP);
 
		hist_jesdown->Add(qcdjet);
		hist_jesdown->Add(mcphojetJESDOWN);


		//get the systematics for the mixture
		//here i am using some dummy mixture for now. change them wisely!

		//clones to be used in the syst calculations. need this before normalizing them
		TH1F* hist_qcdVaried = (TH1F*) qcdjet->Clone("hist_qcdVaried");
		TH1F* hist_mcphoVaried = (TH1F*) mcphojet->Clone("hist_mcphoVaried");

		//don't  i NEED TO subtract off the other backgrounds from data before
		//normalizing QCD/MC pho samples????
		float mcphoMixVaried_Norm = ((phojet->Integral()) * (1 - fake_pho_frac_p) )/mcphojet->Integral();
		hist_mcphoVaried->Scale(mcphoMixVaried_Norm);
		
		float qcdMixVaried_Norm = ((phojet->Integral()) * fake_pho_frac_p)/qcdjet->Integral();
		hist_qcdVaried->Scale(qcdMixVaried_Norm);

		hist_varyMcQcdMixSyst->Add(hist_qcdVaried);
		hist_varyMcQcdMixSyst->Add(hist_mcphoVaried);


	//	DebugJES(hist_err, hist_varyMcQcdMixSyst, hist_varyMcQcdMixSyst, __LINE__, 
	//			"E_{T}^{Lead jet} : What I see for FakePhoFrac+#sigma: compared to total background");
	//	DebugJES(hist_err, hist_mcphoVaried, hist_qcdVaried, __LINE__ ,"E_{T}^{Lead jet} : Scaled (to Data) #gamma MC and Sideband by Fake #gamma fraction compared to total background");
		
		for (int i=1; i <= hist_varyMcQcdMixSyst->GetNbinsX(); i++)
		{
			float err = fabs(hist_varyMcQcdMixSyst->GetBinContent(i) - hist_err->GetBinContent(i));
			qcdmcMixErr.push_back(err);
		}

		//DebugMakeHist(qcdmcMixErr, hist_err);
		//DebugQcdMcMix(hist_varyMcQcdMixSyst, hist_err, phojet);
		//this is new systamatic for the 
	   GetQCD100Err(qcdmcMixErr, hist_qcd100Syst, name, abspath, xmin, xpoint1, xpoint2, xpoint3, xpoint4, width1, width2, width3, width4, true);
	 
  	} else 
	{
		std::cerr << "bad value: QCDerrMtd=" << QCDerrMtd << std::endl;
      return;
	};

	// NOW GET THE SYSTEMATICS FROM JES BY comparing central values with the JES UP/DOWN
	// USE THE HIST USED TO PUT THE ERROR BAND AS THE CENTRAL VALUE

	//DebugJES(hist_err,hist_jesup, hist_jesdown);
	
	
 	std::vector<float> JESerr;
	for (int i=1; i <= hist_err->GetNbinsX(); i++)
	{
			JESerr.push_back(GetMax(hist_err->GetBinContent(i),
											hist_jesup->GetBinContent(i),
											hist_jesdown->GetBinContent(i)));
	}

		// NOW GET THE STAT ERROR
	std::vector<float> statErr;
	for (int i=1; i <= hist_err->GetNbinsX(); i++)
	{
		statErr.push_back(hist_err->GetBinError(i));
	}

	//DebugStatErr(zeejet, zmmjet, zttjet, wenjet, wmnjet, wtnjet,  mcphojet, qcdjet, hist_err);

/*
	TH1* hist_halo = (TH1*) halojet->Clone("hist_halo_copy");
		hist_halo->SetMarkerColor(kBlue);
		hist_halo->SetMarkerStyle(21);
	TH1* hist_cosmic = (TH1*) halojet->Clone("hist_cosmic_copy");
		hist_cosmic->SetMarkerColor(kRed);
		hist_cosmic->SetMarkerStyle(22);
	TH1* hist_zee = (TH1*) halojet->Clone("hist_zee_copy");
		hist_zee->SetMarkerColor(kGreen);
		hist_zee->SetMarkerStyle(23);
	TH1* hist_stat = (TH1*) halojet->Clone("hist_stat_copy");
		hist_stat->SetMarkerColor(5);
		hist_stat->SetMarkerStyle(24);
	TH1* hist_jes = (TH1*) halojet->Clone("hist_jes_copy");
		hist_jes->SetMarkerColor(2);
		hist_jes->SetMarkerStyle(25);
	TH1* hist_qcdmcmix = (TH1*) halojet->Clone("hist_qcd_copy");
		hist_qcdmcmix->SetMarkerColor(6);
		hist_qcdmcmix->SetMarkerStyle(26);
*/

 	// NOW COLLECT ALL ERRORS AND PUT THEM TOGETHER FOR ONE FINAL NUMBER
	std::vector<float> ERRORS;

	std::cout << __FUNCTION__ << ":" << __LINE__ << "::All Errors" << std::endl;
	std::cout << setw(4) << "bin"<< setw(8) << "JES"
				 << setw(8) << "PhoFrac" << setw(8) << "EWK Lum" 
				 << setw(8) << "Cosmic" << setw(8) << "Halo"
				 << setw(8) << "StatErr" << setw(10) << "Total"<< std::endl; 
	for (unsigned int i=0; i < cosmicErr.size(); i++)
	{
		float sum = pow(cosmicErr[i],2) + pow(haloErr[i],2) + pow(zeeLumErr,2) 
						+ pow(zmmLumErr,2)+ pow(zttLumErr,2) + pow(wenLumErr,2) 
						+ pow(wmnLumErr,2) + pow(wtnLumErr,2) + pow(qcdmcMixErr[i],2)
						+ pow(JESerr[i],2) + pow(statErr[i],2);

		ERRORS.push_back(sqrt(sum));

		float ewksum = sqrt( pow(zeeLumErr,2) + pow(zmmLumErr,2)+ pow(zttLumErr,2) 
								 + pow(wenLumErr,2) + pow(wmnLumErr,2) + pow(wtnLumErr,2));

		// now set the sum of background hists error to this total
		if (hist_err->GetBinContent(i+1))
		{
			hist_err->SetBinError(i+1, ERRORS.at(i));
		}
		
		std::cout << setiosflags(ios::fixed) << setprecision(1) 
			<< setw(4) << i+1 << setw(8) << JESerr[i]
			<< setw(8) << qcdmcMixErr[i] << setw(8) << ewksum 
			<< setw(8) << cosmicErr[i] << setw(8) << haloErr[i]
			<< setw(8) << statErr[i] << setw(10) << ERRORS.at(i) << std::endl; 
/*
		int bin =i+1;
		hist_halo->SetBinContent(bin, haloErr.at(i));
		hist_halo->SetBinError(bin, 0);
		hist_cosmic->SetBinContent(bin, cosmicErr.at(i));
		hist_cosmic->SetBinError(bin, 0);
		hist_zee->SetBinContent(bin, ewksum);
		hist_zee->SetBinError(bin, 0);
		hist_qcdmcmix->SetBinContent(bin, qcdmcMixErr.at(i));
		hist_qcdmcmix->SetBinError(bin, 0);
		hist_stat->SetBinContent(bin, statErr.at(i));
		hist_stat->SetBinError(bin, 0);
		hist_jes->SetBinContent(bin, JESerr.at(i));
		hist_jes->SetBinError(bin, 0);
*/

	}
/*	
	TH1* myhist = (TH1*) halojet->Clone("temp_myhist");
	myhist->SetDirectory(0);

	for (unsigned bin=1; bin<= (unsigned) myhist->GetNbinsX(); ++bin)
	{
		myhist->SetBinContent(bin,ERRORS.at(bin-1));
		myhist->SetBinError(bin,0);
	}
*/

	MakeRatioPlot(which, jets, phojet,hist_err, ERRORS,true);

	
/*
 	// I am commenting this part out temorily to see the real
	// values of systematics - 8-28-2009
	TF1* func = MakeRatioPlot(which, jets, phojet,hist_err, ERRORS,true);
	
	assert(func != NULL && "func is null");
	assert(hist_err != NULL && "hist_err is null");

  for (int bin = 1; bin <= hist_err->GetNbinsX(); ++ bin)
  {
	 	hist_err->SetBinError (bin, func->Eval (hist_err->GetXaxis()->GetBinCenter (bin)) * hist_err->GetBinContent (bin));
		float err = func->Eval (hist_err->GetXaxis()->GetBinCenter (bin)) * hist_err->GetBinContent (bin);
		float cont = hist_err->GetBinContent(bin);
		float loed = hist_err->GetXaxis()->GetBinLowEdge(bin);

  }
*/
	//std::cout << "\n -------------- " << __FUNCTION__ << ":" << __LINE__ << " " << std::endl;



  //************* SET HIST COLORS ***************************************

	Int_t linecolor=47;

  mcphojet->SetLineColor(linecolor);
  mcphojet->SetFillColor(6);
  qcdjet->SetLineColor(linecolor);
  qcdjet->SetFillColor(kYellow);
  cosmicjet->SetLineColor(linecolor);
  cosmicjet->SetFillColor(kGreen);
  halojet->SetLineColor(linecolor);
  halojet->SetFillColor(12);
  int ewkColor = 29;
  zeejet->SetLineColor(linecolor);
  zeejet->SetFillColor(ewkColor);
  zmmjet->SetLineColor(ewkColor);
  zmmjet->SetFillColor(ewkColor);
  zttjet->SetLineColor(ewkColor);
  zttjet->SetFillColor(ewkColor);
  wenjet->SetLineColor(ewkColor);
  wenjet->SetFillColor(ewkColor);
  wmnjet->SetLineColor(ewkColor);
  wmnjet->SetFillColor(ewkColor);
  wtnjet->SetLineColor(ewkColor);
  wtnjet->SetFillColor(ewkColor);

  phojet->SetLineColor(kBlack);
  phojet->SetMarkerStyle (8);

  //this is the line histo showing 100% of QCD 0% MC pho
  qcdjet_100->SetLineColor(kRed);
  qcdjet_100->SetFillColor(kYellow);
  hist_err->SetFillStyle(3001);
  hist_err->SetFillColor(13);
  hist_err->SetLineColor(10);
 

  //********* MAKE THE PLOT ***************************************
  THStack *hs = new THStack ("hs", NULL);

  if (QCDerrMtd == 1) {//plots that use 100% qcd
    hs->Add(halojet);
    hs->Add(cosmicjet);
    hs->Add(zmmjet);
    hs->Add(wtnjet);
    hs->Add(zttjet);
    hs->Add(wmnjet);
    hs->Add(wenjet);
    hs->Add(zeejet);
    hs->Add(qcdjet_100);

  } else if (QCDerrMtd == 2) {//plots that use 30%70%
    hs->Add(halojet);
    hs->Add(cosmicjet);
    hs->Add(zmmjet);
    hs->Add(wtnjet);
    hs->Add(zttjet);
    hs->Add(wmnjet);
    hs->Add(wenjet);
    hs->Add(zeejet);
    hs->Add(qcdjet);
    hs->Add(mcphojet);
  } else {
    std::cerr << "bad value: QCDerrMtd=" << QCDerrMtd << std::endl;
    return;
  };

  TLegend *leg = new TLegend (0.5,0.6,0.9,0.9);
  leg->SetTextFont(42);
  leg->SetTextSize(0.03);
  std::string str_pho,str_cosmic,str_halo,str_zee,str_zmm,str_ztt,str_wen,str_wmn,str_wtn;

  if (jets==1) {
    str_pho 	= "Data (#gamma + >=1 Jet)";	
    str_cosmic = "#gamma^{cosmic} + >=1 Jet";
    str_zee 	= "Z->ee MC (e + >=1 Jet)";
    str_wen 	= "W->e#nu MC (e + >=1 Jet)";
    str_ztt 	= "Z->#tau#tau MC (e + >=1 Jet)";
    str_wtn 	= "W->#tau#nu MC (e + >=1 Jet)";
    str_wmn 	= "W->#mu#nu MC (e + >=1 Jet)";
    str_zmm 	= "Z->#mu#mu MC (e + >=1 Jet)";
    str_halo 	= "#gamma^{halo} + >=1 Jet";
  }
  if (jets==2) {
    str_pho 	= "Data (#gamma + >=2 Jets)";	
    str_cosmic = "#gamma^{cosmic} + >=2 Jets";
    str_zee 	= "Z->ee MC (e + >=2 Jets)";
    str_wen 	= "W->e#nu MC (e + >=2 Jets)";
    str_ztt 	= "Z->#tau#tau MC (e + >=2 Jets)";
    str_wtn 	= "W->#tau#nu MC (e + >=2 Jets)";
    str_wmn 	= "W->#mu#nu MC (e + >=2 Jets)";
    str_zmm 	= "Z->#mu#mu MC (e + >=2 Jets)";
    str_halo 	= "#gamma^{halo} + >=2 Jets";
  }
	

  if (QCDerrMtd == 1) {//plots that use 100% qcd
    leg->AddEntry(phojet,str_pho.c_str());
    leg->AddEntry(qcdjet_100, "QCD (100% #gamma sideband)");
    leg->AddEntry(wtnjet,"EWK MC");
    leg->AddEntry(cosmicjet,str_cosmic.c_str());
    leg->AddEntry(halojet,str_halo.c_str());
    leg->AddEntry(hist_err,"Systematics Uncertainty");

  } else if (QCDerrMtd == 2) {//plots that use 30%70%
    leg->AddEntry(phojet,str_pho.c_str());
    leg->AddEntry(mcphojet,mc_str.c_str());
    leg->AddEntry(qcdjet,qcd_str.c_str());
    leg->AddEntry(wtnjet,"EWK MC");
    leg->AddEntry(cosmicjet,str_cosmic.c_str());
    leg->AddEntry(halojet,str_halo.c_str());
    leg->AddEntry(hist_err,"Systematic Uncertainty");
  } else {
    std::cerr << "bad value: QCDerrMtd=" << QCDerrMtd << std::endl;
    return;
  };

	leg->SetBorderSize (1);
	leg->SetFillColor (10);
	gStyle->SetCanvasColor (10);
	gStyle->SetCanvasBorderSize (0);
	gStyle->SetCanvasBorderMode (0);

	gStyle->SetPadColor (10);
	gStyle->SetFillColor (10);
	gStyle->SetTitleFillColor (10);
	gStyle->SetTitleBorderSize (1);
	gStyle->SetStatColor (10);
	gStyle->SetStatBorderSize (1);


	new TCanvas();
	gStyle->SetTextFont(132);
	hs->SetMinimum(0.05);
	if (jets == 1) hs->SetMaximum(0.5e6);
	if (jets == 2) hs->SetMaximum(0.5e5);
	if (jets == 2 && which == "LeadJetEt") hs->SetMaximum(0.5e6);
	if (which == "NJet") hs->SetMaximum(0.5e7);


	gPad->SetLogy();
	gPad->SetTickx();
	gPad->SetTicky();
	hs->Draw("HIST");		//need this as I am calling sumw2 for all hists. if not it will draw all hists with error bars

	hs->GetXaxis()->SetTitle (title.c_str());
	std::ostringstream ytitle;
	//if (which == "PhotonEt") ytitle << "#Delta N/ #Delta E_{T}";
	//if (which == "InvMass") ytitle << "#Delta N/ #Delta M";
	std::string xtitle, yunits;
	if (which =="PhotonEt") { xtitle += "E_{T}^{ #gamma} (GeV)"; yunits= "GeV"; }
	if (which =="InvMass") { xtitle += "Invariant Mass(#gamma, Lead Jet) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (jets ==2 && which =="PhoJetsInvMass") { xtitle += "Invariant Mass(#gamma, Two Lead Jets) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (which =="Ht") xtitle += "H_{T} (GeV)";
	if (which =="JetsInvMass") { xtitle += "Invariant Mass(Two Lead Jets) (GeV/c^{2})"; yunits= "GeV/c^{2}"; }
	if (which =="LeadJetEt") xtitle += "E_{T}^{Lead Jet} (GeV)";
	if (which =="SecondLeadJetEt") xtitle += "E_{T}^{Second Lead Jet} (GeV)";

	if (which == "NJet") ytitle << "Events";
	else ytitle << "Events / " << phojet->GetBinWidth(1) << " " << yunits;
	hs->GetYaxis()->SetTitle (ytitle.str().c_str());

	int labelfont = 10 * 4 + 2;		//10 * fond ID + precision (2 = scalable)
	int titlefont = 10 * 4 + 2;		//10 * fond ID + precision (2 = scalable)
	hs->GetXaxis()->SetLabelFont(labelfont);
	hs->GetYaxis()->SetLabelFont(labelfont);
	hs->GetYaxis()->SetLabelSize(0.05);
	hs->GetXaxis()->SetLabelSize(0.05);
	hs->GetXaxis()->SetTitleFont(titlefont);
	hs->GetYaxis()->SetTitleFont(titlefont);
	hs->GetYaxis()->SetTitleSize(0.05);
	hs->GetXaxis()->SetTitleSize(0.05);
	hs->GetXaxis()->SetTitleOffset(0.9);
	hs->GetYaxis()->SetTitleOffset(0.9);
	hs->GetXaxis()->CenterTitle(true);
	hs->GetYaxis()->CenterTitle(true);


	hist_err->SetDrawOption("HIST");
	hist_err->Draw("sameE2");
	phojet->Draw("same");
	leg->Draw ();

	// for debugging only
	new TCanvas();

	TH1* sdHist = (TH1*) phojet->Clone("sam_datahist");
	TH1* sbHist = (TH1*) hist_err->Clone("sam_bckghist");
	sdHist->SetDirectory(0);
	sbHist->SetDirectory(0);
	//sdHist->Sumw2();
	//sbHist->Sumw2();
	sdHist->Divide(sbHist);
	sdHist->SetMarkerStyle(20);
	sdHist->SetMarkerSize(1.5);
	sbHist->Draw("PE2");
	
  
	std::cout << __FUNCTION__ << ":" << __LINE__ << "::hist_DATA ========" << std::endl;
	Debug_DumpHist(phojet, __LINE__,4);
	std::cout << __FUNCTION__ << ":" << __LINE__ << "::hist_ERR =========" << std::endl;
	Debug_DumpHist(hist_err, __LINE__,4);
	std::cout << __FUNCTION__ << ":" << __LINE__ << "::hist_JESUP =======" << std::endl;
	Debug_DumpHist(hist_jesup, __LINE__,4);
	std::cout << __FUNCTION__ << ":" << __LINE__ << "::hist_JESDOWN =====" << std::endl;
	Debug_DumpHist(hist_jesdown, __LINE__,4);

	// end debug stuff


  
	TPaveText *tp = new TPaveText(0.5,0.91,0.9,0.99,"NDC");
	tp->SetLineColor(10);
	tp->SetTextFont(titlefont);
	tp->AddText("CDF Run II Preliminary 2.0 fb^{-1}");
	tp->Draw();

	bool mark_overflow = false;
  	if (QCDerrMtd == 1) {//plots that use 100% qcd
    	if ( halojet->GetBinContent(halojet->GetNbinsX()) ||
				 cosmicjet->GetBinContent(cosmicjet->GetNbinsX()) ||
				 zmmjet->GetBinContent(zmmjet->GetNbinsX()) ||
				 wtnjet->GetBinContent(wtnjet->GetNbinsX()) ||
				 zttjet->GetBinContent(zttjet->GetNbinsX()) ||
				 wmnjet->GetBinContent(wmnjet->GetNbinsX()) ||
				 wenjet->GetBinContent(wenjet->GetNbinsX()) ||
				 zeejet->GetBinContent(zeejet->GetNbinsX()) ||
				 qcdjet_100->GetBinContent(qcdjet_100->GetNbinsX()) )
			mark_overflow = true;

  } else if (QCDerrMtd == 2) {//plots that use 30%70%
    if ( halojet->GetBinContent(halojet->GetNbinsX()) ||
				 cosmicjet->GetBinContent(cosmicjet->GetNbinsX()) ||
				 zmmjet->GetBinContent(zmmjet->GetNbinsX()) ||
				 wtnjet->GetBinContent(wtnjet->GetNbinsX()) ||
				 zttjet->GetBinContent(zttjet->GetNbinsX()) ||
				 wmnjet->GetBinContent(wmnjet->GetNbinsX()) ||
				 wenjet->GetBinContent(wenjet->GetNbinsX()) ||
				 zeejet->GetBinContent(zeejet->GetNbinsX()) ||
				 qcdjet->GetBinContent(qcdjet->GetNbinsX()) ||
				 mcphojet->GetBinContent(mcphojet->GetNbinsX()) )
			mark_overflow = true;
  }
  
  if (mark_overflow)
  {
		gPad->Range(0,0,1,1);

		TLine *line = new TLine();
		line->SetLineWidth(2);
		line->DrawLineNDC(0.895,0.218,0.93,0.218);
		
		TText *tt = new TText(0.95,0.15,"Overflow bin");
			tt->SetTextFont(titlefont);
			tt->SetTextAngle(90);
			tt->SetTextSize(0.035);
			tt->SetTextColor(kBlue);
			tt->SetNDC();

		tt->Draw();
  }

  	//phojet->Print();
	//std::cout << "bin 1 = " <<  phojet->GetBinContent(1) << std::endl;
	//std::cout << "bin 2 = " <<  phojet->GetBinContent(2) << std::endl;
	//std::cout << "bin 3 = " <<  phojet->GetBinContent(3) << std::endl;
	//std::cout << "bin3/bin2 = " << (phojet->GetBinContent(3)/phojet->GetBinContent(2)) << std::endl;


}

void MakeHistLogAndRatio (int jets, std::string which)
{
  TVirtualPad *pad_old = gPad;	
  	int qcd100 = 1;
	int qcdMcMix = 2;
	if (which == "NJet") qcdMcMix=1;
	
	// to make full scale plots
	if (jets == 1) {
		if (which == "PhotonEt") 	MakeHistLogAndRatio (which, jets, "EtCorr","E_{T}^{#gamma} (GeV)","1Jet/Photon", qcdMcMix,0,200,250,300,650, 10,10,50,250);
		else if (which == "InvMass") 	MakeHistLogAndRatio (which, jets, "InvMass","Invariant Mass (#gamma,Lead Jet) (GeV/c^{2})","1Jet/PhotonLeadJet", qcdMcMix, 50,500, 600, 700, 1000, 25,50,75,300);
		else if (which == "Ht") 	MakeHistLogAndRatio (which, jets, "Ht","H_{T} (GeV)","1Jet/Event", qcdMcMix, 0,300, 600, 800, 1200, 20,50,100,300);
		else if (which == "LeadJetEt") 	MakeHistLogAndRatio (which, jets, "EtCorr","E_{T}^{Lead Jet} (GeV)","1Jet/LeadJet", qcdMcMix,0,200,250,300,600, 10,10,50,200);
    	else if (which == "NJet") 	MakeHistLogAndRatio (which, jets, "NJet15","Jet Multiplicity (E_{T}>15GeV)", "1Jet/Event",qcdMcMix,0,1,2,3,15, 1,1,1,1);
		else if (which == "LeadJetEt") 	MakeHistLogAndRatio (which, jets, "EtCorr","E_{T}^{#gamma} (GeV)","1Jet/LeadJet", qcdMcMix,0,200,250,300,650, 10,10,50,250);
    	else if (which == "Met") 	MakeHistLogAndRatio (which, jets, "Met","MEt", "1Jet/Event",qcdMcMix,0,300,600,800,1200, 20,50,100,300);
	}

	if (jets == 2) {
		if (which == "PhotonEt") 	MakeHistLogAndRatio (which, jets, "EtCorr","E_{T}^{#gamma} (GeV)","2Jet/Photon", qcdMcMix,0,150,250,300,600, 10,20,50,250);
		else if (which == "InvMass") 	MakeHistLogAndRatio (which, jets, "InvMass","Invariant Mass (#gamma,Lead Jet) (GeV/c^{2})","2Jet/PhotonLeadJet", qcdMcMix, 100, 200, 300, 700, 1000, 10,20,50,200);
		else if (which == "PhoJetsInvMass") 	MakeHistLogAndRatio (which, jets, "InvMass","Invariant Mass (#gamma, Two Lead Jets) (GeV/c^{2})","2Jet/Photon2Jets", qcdMcMix, 100, 200, 300, 700, 1300, 10,20,50,200);
		else if (which == "Ht") 	MakeHistLogAndRatio (which, jets, "Ht","H_{T} (GeV)","2Jet/Event", qcdMcMix, 0,300, 600, 700, 1200, 20,50,100,400);
		else if (which == "JetsInvMass") MakeHistLogAndRatio (which, jets, "InvMass","Invariant Mass (Two Lead Jets) (GeV/c^{2})","2Jet/2Jets", qcdMcMix, 100, 200, 300, 700, 1200, 10,20,50,400);
		else if (which == "LeadJetEt") 	MakeHistLogAndRatio (which, jets, "EtCorr","E_{T}^{Lead Jet} (GeV)","1Jet/LeadJet", qcdMcMix,0,200,260,300,600, 10,20,40,200);
		else if (which == "SecondLeadJetEt") 	MakeHistLogAndRatio (which, jets, "EtCorr","E_{T}^{Second Lead Jet} (GeV)","2Jet/SecondLeadJet", qcdMcMix,0,100,160,200,600, 10,20,40,200);
	}
	

	if (gPad != pad_old)
	{
		TCanvas *c = dynamic_cast<TCanvas*>(gPad);
		//c->SetFillColor(kRed);
      if (c)
		{
			std::ostringstream str,str1,str2;
			str << "plot" << jets << "_" << which << ".gif";
			//c->Print (str.str().c_str());
			str1 << "plot" << jets << "_" << which << ".pdf";
			//c->Print (str1.str().c_str(),"pdf");
			str2 << "plot" << jets << "_" << which << ".eps";
			//c->Print (str2.str().c_str(),"eps");
		};
	};

};

void MakeHistLogAndRatio ()
{
	//good plots that works

	//MakeHistLogAndRatio (1, "PhotonEt");
	//MakeHistLogAndRatio (2, "PhotonEt");
	//MakeHistLogAndRatio (1, "InvMass");
	//MakeHistLogAndRatio (2, "InvMass");
	//MakeHistLogAndRatio (2, "PhoJetsInvMass");
	//MakeHistLogAndRatio (2, "JetsInvMass");
	//MakeHistLogAndRatio (1, "NJet");


	//MakeHistLogAndRatio (1, "Ht");
	//MakeHistLogAndRatio (2, "Ht");
	


	//MakeHistLogAndRatio (1, "NJet");
	//MakeHistLogAndRatio (1, "Met");
	MakeHistLogAndRatio (1, "LeadJetEt");
	//MakeHistLogAndRatio (2, "LeadJetEt");
	//MakeHistLogAndRatio (2, "SecondLeadJetEt");
};
